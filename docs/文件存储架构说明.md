# 文件存储架构说明

## 📚 核心概念：双表设计

云盘系统使用**双表设计**实现文件去重和用户文件管理：

1. **`repository_pool`** - 文件物理存储池（全局唯一）
2. **`user_repository`** - 用户文件关联表（个人网盘）

---

## 🗄️ 表结构详解

### 1️⃣ repository_pool（文件存储池）

**作用：** 存储文件的**物理实体**，全局唯一，实现文件去重。

```sql
CREATE TABLE repository_pool (
    id         INT AUTO_INCREMENT PRIMARY KEY,
    identity   VARCHAR(36) UNIQUE NOT NULL,  -- 文件唯一标识（UUID）
    hash       VARCHAR(32) UNIQUE NOT NULL,  -- 文件 MD5 hash（去重关键）
    name       VARCHAR(255) NOT NULL,        -- 原始文件名
    ext        VARCHAR(30),                  -- 文件扩展名（.pdf, .jpg）
    size       BIGINT,                       -- 文件大小（字节）
    path       VARCHAR(500),                 -- OSS 存储路径
    created_at DATETIME,
    updated_at DATETIME,
    deleted_at DATETIME
);
```

**特点：**
- ✅ **全局唯一**：一个文件只存储一次（基于 MD5 hash）
- ✅ **秒传机制**：上传前检查 hash，已存在则直接返回
- ✅ **节省空间**：多个用户上传同一文件，只占用一份存储
- ✅ **物理存储**：对应 OSS 上的实际文件

**字段说明：**
| 字段 | 说明 | 示例 |
|------|------|------|
| `identity` | 文件唯一标识 | `f337fbd7-b281-4696-a8a8-b7d3bf64d12a` |
| `hash` | MD5 hash（去重） | `5d41402abc4b2a76b9719d911017c592` |
| `name` | 原始文件名 | `example.pdf` |
| `ext` | 文件扩展名 | `.pdf` |
| `size` | 文件大小 | `1048576`（1MB） |
| `path` | OSS 存储路径 | `https://bucket.oss-cn-beijing.aliyuncs.com/xxx.pdf` |

---

### 2️⃣ user_repository（用户文件仓库）

**作用：** 建立**用户与文件的关联关系**，实现个人网盘功能。

```sql
CREATE TABLE user_repository (
    id                   INT AUTO_INCREMENT PRIMARY KEY,
    identity             VARCHAR(36) UNIQUE NOT NULL,  -- 用户文件记录唯一标识
    user_identity        VARCHAR(36) NOT NULL,         -- 用户标识（关联到用户表）
    parent_id            BIGINT DEFAULT 0,             -- 父文件夹 ID（文件夹层级）
    repository_identity  VARCHAR(36) NOT NULL,         -- 关联到 repository_pool.identity
    name                 VARCHAR(255) NOT NULL,        -- 用户自定义文件名（可重命名）
    ext                  VARCHAR(30),                  -- 文件扩展名
    created_at           DATETIME,
    updated_at           DATETIME,
    deleted_at           DATETIME,
    INDEX idx_user_parent (user_identity, parent_id)  -- 查询优化
);
```

**特点：**
- ✅ **用户隔离**：每个用户有自己的文件列表
- ✅ **文件共享**：多个用户可以关联同一个物理文件
- ✅ **文件夹结构**：通过 `parent_id` 实现层级目录
- ✅ **重命名支持**：用户可以自定义文件名
- ✅ **软删除**：删除文件不影响其他用户

**字段说明：**
| 字段 | 说明 | 示例 |
|------|------|------|
| `identity` | 用户文件记录标识 | `ur_123456-abcd-...` |
| `user_identity` | 用户标识 | `user_abc123` |
| `parent_id` | 父文件夹 ID | `0`（根目录）或 `123`（某文件夹） |
| `repository_identity` | 关联到 `repository_pool` | `f337fbd7-b281-4696-a8a8-...` |
| `name` | 用户自定义文件名 | `我的重要文档.pdf` |

---

## 🔄 工作流程

### 场景 1：用户 A 首次上传文件

```
1. 客户端上传文件 "report.pdf"
   ↓
2. 服务端计算 MD5: "abc123..."
   ↓
3. 检查 repository_pool.hash
   └─ 不存在 → 继续上传
   ↓
4. 上传到 OSS，获得 path
   ↓
5. 插入 repository_pool
   ├─ identity: "file_001"
   ├─ hash: "abc123..."
   ├─ name: "report.pdf"
   └─ path: "https://oss.../file_001.pdf"
   ↓
6. 调用 /user/repository 接口
   ↓
7. 插入 user_repository
   ├─ user_identity: "user_A"
   ├─ repository_identity: "file_001"
   ├─ name: "report.pdf"
   └─ parent_id: 0 (根目录)
   ↓
8. 返回成功 ✅
```

---

### 场景 2：用户 B 上传相同文件（秒传）

```
1. 客户端上传文件 "report.pdf"
   ↓
2. 服务端计算 MD5: "abc123..."
   ↓
3. 检查 repository_pool.hash
   └─ 已存在！identity = "file_001"
   ↓
4. 直接返回 file_001（秒传，不上传 OSS）
   ↓
5. 调用 /user/repository 接口
   ↓
6. 插入 user_repository
   ├─ user_identity: "user_B"
   ├─ repository_identity: "file_001"（复用）
   ├─ name: "公司报告.pdf"（重命名）
   └─ parent_id: 0
   ↓
7. 返回成功 ✅（同一文件，两个用户，只存一份）
```

**关键点：**
- `repository_pool` 中只有 **1 条记录**（物理文件）
- `user_repository` 中有 **2 条记录**（用户 A 和 B 各一条）
- OSS 上只有 **1 个文件**

---

### 场景 3：用户查看文件列表

```
1. 客户端调用 /user/list
   ├─ id: 0（根目录）
   ├─ page: 1
   └─ size: 20
   ↓
2. 查询 user_repository
   WHERE user_identity = "user_A"
     AND parent_id = 0
   LIMIT 20 OFFSET 0
   ↓
3. 获取 repository_identity 列表
   ↓
4. 关联查询 repository_pool（获取 size 等信息）
   ↓
5. 返回文件列表
   [
     {
       "id": 1,
       "identity": "ur_001",
       "name": "report.pdf",
       "ext": ".pdf",
       "size": 1048576,
       "repository_identity": "file_001"
     },
     ...
   ]
```

---

## 📡 API 接口说明

### 1️⃣ POST /api/file/upload

**作用：** 上传文件到 `repository_pool`（物理存储）

**流程：**
1. 接收文件上传
2. 计算 MD5 hash
3. 检查是否秒传（hash 是否存在）
4. 上传到 OSS（如需）
5. 插入 `repository_pool`
6. 返回 `identity`（文件标识）

**返回：**
```json
{
  "identity": "file_001",
  "name": "report.pdf",
  "ext": ".pdf"
}
```

**注意：** 此接口**不建立用户关联**，需要配合 `/user/repository` 使用。

---

### 2️⃣ POST /api/file/user/repository

**作用：** 将文件关联到用户网盘（`user_repository`）

**请求：**
```json
{
  "parent_id": 0,
  "repository_identity": "file_001",
  "name": "我的报告.pdf",
  "ext": ".pdf"
}
```

**流程：**
1. 从 JWT token 获取 `user_identity`
2. 插入 `user_repository` 记录
3. 建立用户与文件的关联

**返回：**
```json
{
  "identity": "ur_001"
}
```

**使用场景：**
- ✅ 用户上传文件后保存到网盘
- ✅ 文件分享后保存到自己网盘
- ✅ 文件复制到其他文件夹

---

### 3️⃣ POST /api/file/user/list

**作用：** 查询用户的文件列表（从 `user_repository`）

**请求：**
```json
{
  "id": 0,      // 文件夹 ID（0=根目录）
  "page": 1,    // 页码
  "size": 20    // 每页数量
}
```

**流程：**
1. 从 JWT token 获取 `user_identity`
2. 查询 `user_repository`（WHERE user_identity AND parent_id）
3. 关联 `repository_pool` 获取文件详情（size, path）
4. 返回分页结果

**返回：**
```json
{
  "list": [
    {
      "id": 1,
      "identity": "ur_001",
      "name": "我的报告.pdf",
      "ext": ".pdf",
      "size": 1048576,
      "repository_identity": "file_001"
    }
  ],
  "count": 100
}
```

**使用场景：**
- ✅ 显示网盘首页
- ✅ 进入文件夹查看文件
- ✅ 分页加载大量文件

---

## 🎯 双表设计的优势

### ✅ 1. 文件去重（节省存储成本）

**问题：** 100 个用户上传同一个 100MB 文件

**单表设计：**
- 存储空间：100 × 100MB = **10GB**
- OSS 费用：**10GB 费用**

**双表设计：**
- `repository_pool`：1 个文件（100MB）
- `user_repository`：100 条记录（几 KB）
- 存储空间：**100MB + 几 KB ≈ 100MB**
- OSS 费用：**100MB 费用**
- **节省 99% 存储成本！**

---

### ✅ 2. 秒传功能（提升用户体验）

**用户体验对比：**

| 场景 | 单表设计 | 双表设计 |
|------|---------|---------|
| 上传已存在文件 | 需要上传 5 分钟 | **秒传，0.1 秒** |
| 网络消耗 | 100MB 上传 | 几 KB 请求 |
| 用户感知 | 等待漫长 | 瞬间完成 |

---

### ✅ 3. 文件共享（天然支持）

**共享流程：**
```
用户 A 分享文件给用户 B
  ↓
用户 B "保存到我的网盘"
  ↓
插入一条 user_repository 记录
  ├─ user_identity: "user_B"
  └─ repository_identity: 复用 A 的文件
  ↓
完成！无需复制文件，瞬间完成
```

---

### ✅ 4. 独立管理（用户隔离）

**用户 A 删除文件：**
```
DELETE FROM user_repository
WHERE user_identity = "user_A"
  AND identity = "ur_001"
  ↓
只删除关联记录，不影响：
  ✅ repository_pool 中的物理文件
  ✅ 用户 B 的文件（他也有这个文件）
```

**真正删除文件：**
只有当 `user_repository` 中没有任何用户关联时，才从 `repository_pool` 和 OSS 删除物理文件（可用定时任务清理）。

---

### ✅ 5. 重命名和移动（灵活操作）

**用户可以自由操作：**
- ✅ 重命名：修改 `user_repository.name`
- ✅ 移动：修改 `user_repository.parent_id`
- ✅ 复制：新增一条 `user_repository` 记录
- ✅ 不影响其他用户

---

## 📊 数据关系示意图

```
┌─────────────────────────────────────────────┐
│         repository_pool (文件物理存储)          │
├─────────────────────────────────────────────┤
│ id | identity  | hash    | name    | path   │
├─────────────────────────────────────────────┤
│ 1  | file_001  | abc123  | rep.pdf | oss... │ ← 物理文件（全局唯一）
└─────────────────────────────────────────────┘
                        ↑
                        │ repository_identity
        ┌───────────────┴───────────────┐
        │                               │
┌───────────────────────────┐  ┌───────────────────────────┐
│    user_repository        │  │    user_repository        │
│    (用户 A 的网盘)          │  │    (用户 B 的网盘)          │
├───────────────────────────┤  ├───────────────────────────┤
│ user_identity: user_A     │  │ user_identity: user_B     │
│ repository_identity:      │  │ repository_identity:      │
│   file_001               │  │   file_001 (相同!)        │
│ name: "报告.pdf"          │  │ name: "公司报告.pdf"       │
│ parent_id: 0 (根目录)     │  │ parent_id: 0 (根目录)     │
└───────────────────────────┘  └───────────────────────────┘
```

**关键点：**
- 1 个 `repository_pool` 记录 = 1 个物理文件
- N 个 `user_repository` 记录 = N 个用户拥有此文件
- 文件去重：多个用户关联同一个 `repository_identity`

---

## 🔍 常见问题 FAQ

### Q1: 为什么不用一张表？

**单表问题：**
```sql
CREATE TABLE user_files (
    id INT,
    user_identity VARCHAR(36),
    name VARCHAR(255),
    path VARCHAR(500),  -- 每个用户存一份路径
    ...
);
```

❌ **问题：**
- 同一文件多次上传到 OSS（浪费存储）
- 无法实现秒传（每次都要上传）
- 无法实现文件共享（需要复制文件）
- 存储成本高

---

### Q2: 如果用户 A 删除文件，用户 B 还能看到吗？

✅ **能！**

- 用户 A 删除：只删除 `user_repository` 中的**关联记录**
- `repository_pool` 中的物理文件**保持不变**
- 用户 B 的 `user_repository` 记录**不受影响**

---

### Q3: 什么时候真正删除 OSS 上的文件？

**推荐方案：定时清理**

```sql
-- 查找没有任何用户关联的文件
SELECT rp.*
FROM repository_pool rp
LEFT JOIN user_repository ur ON rp.identity = ur.repository_identity
WHERE ur.id IS NULL;
```

**清理策略：**
1. 每天定时任务运行
2. 找出没有用户关联的文件
3. 从 OSS 删除文件
4. 从 `repository_pool` 删除记录

---

### Q4: 上传流程是否需要调用两个接口？

✅ **是的，标准流程：**

```javascript
// 1. 上传文件到存储池
const uploadRes = await fetch('/api/file/upload', {
  method: 'POST',
  body: formData
});
const { identity } = await uploadRes.json();

// 2. 关联到用户网盘
const repoRes = await fetch('/api/file/user/repository', {
  method: 'POST',
  body: JSON.stringify({
    repository_identity: identity,
    name: '我的文件.pdf',
    ext: '.pdf',
    parent_id: 0
  })
});
```

**为什么分两步？**
- ✅ 职责分离：上传 ≠ 保存到网盘
- ✅ 灵活性：同一文件可以多次保存到不同位置
- ✅ 分享场景：无需上传，直接关联

---

## 🚀 总结

### repository_pool（文件存储池）
- 🎯 **职责**：存储物理文件
- 🔑 **关键**：全局唯一，基于 hash 去重
- 💾 **对应**：OSS 上的实际文件
- 📊 **数据量**：等于物理文件数量

### user_repository（用户文件仓库）
- 🎯 **职责**：用户与文件的关联关系
- 🔑 **关键**：用户隔离，支持重命名/移动
- 🗂️ **对应**：用户网盘中的文件列表
- 📊 **数据量**：等于所有用户的文件总数

### 核心优势
1. ✅ **文件去重** - 节省 99% 存储成本
2. ✅ **秒传功能** - 提升 100 倍上传速度
3. ✅ **文件共享** - 天然支持，无需复制
4. ✅ **用户隔离** - 独立管理，互不影响
5. ✅ **灵活操作** - 支持重命名、移动、复制

这就是云盘系统的核心架构设计！🎉

# 异步文件上传系统架构设计

## 📋 目录
- [1. 系统概述](#1-系统概述)
- [2. 架构设计](#2-架构设计)
- [3. 技术选型](#3-技术选型)
- [4. 数据结构设计](#4-数据结构设计)
- [5. 核心流程](#5-核心流程)
- [6. API 设计](#6-api-设计)
- [7. 实现步骤](#7-实现步骤)
- [8. 部署清单](#8-部署清单)

---

## 1. 系统概述

### 1.1 业务场景
- 支持大文件上传（最大 10GB）
- 视频文件自动压缩
- 实时显示上传进度
- 支持断点续传
- 秒传功能（文件去重）

### 1.2 设计目标
- ✅ 快速响应客户端（< 1秒返回）
- ✅ 解耦上传和处理逻辑
- ✅ 实时进度反馈
- ✅ 高并发处理能力
- ✅ 任务可追踪、可重试
- ✅ 横向扩展能力

---

## 2. 架构设计

### 2.1 整体架构图

```
┌─────────────┐
│   客户端    │
└──────┬──────┘
       │ 上传文件
       ↓
┌─────────────────────────────────────────┐
│          API Server (Go-Zero)           │
│  1. 接收文件 → 临时存储                  │
│  2. 计算 Hash → 检查秒传                 │
│  3. 创建任务 → 存入 Redis                │
│  4. 发送到 MQ → 立即返回 task_id         │
└───────┬─────────────────────────────────┘
        │
        ↓
┌───────────────────┐
│    RabbitMQ       │
│  (消息队列)        │
└───────┬───────────┘
        │
        ↓
┌─────────────────────────────────────────┐
│         Worker (后台处理器)              │
│  1. 消费 MQ 消息                         │
│  2. 视频压缩 (ffmpeg)                    │
│  3. 上传到 OSS                           │
│  4. 更新 Redis 状态                      │
│  5. 发布 Pub/Sub 通知                    │
└─────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────┐
│            Redis                         │
│  - 任务状态存储 (String/Hash)            │
│  - 进度实时更新                          │
│  - Pub/Sub 推送通知                      │
│  - 自动过期清理 (TTL 24h)                │
└─────────────────────────────────────────┘
        ↓
┌─────────────────────────────────────────┐
│      WebSocket / SSE                     │
│  实时推送进度给客户端                     │
└─────────────────────────────────────────┘
```

### 2.2 核心流程

```
客户端上传 
  ↓
[API] 接收文件 → 保存临时目录 → 计算 hash
  ↓
[API] 检查秒传（通过 hash）
  ├── 已存在 → 直接返回文件 identity
  └── 不存在 → 创建上传任务
       ↓
[API] 任务存入 Redis (status: received, progress: 10%)
  ↓
[API] 发送消息到 RabbitMQ
  ↓
立即返回 task_id 给客户端
  ↓
[Worker] 从 MQ 消费任务
  ↓
[Worker] 更新状态 → Redis (status: processing, progress: 30%)
  ↓
[Worker] 判断是否视频
  ├── 是视频 → ffmpeg 压缩 (progress: 30-60%)
  └── 非视频 → 跳过压缩
       ↓
[Worker] 上传到 OSS (progress: 60-90%)
  ↓
[Worker] 保存到文件池 (repository_pool)
  ↓
[Worker] 更新状态 → Redis (status: completed, progress: 100%)
  ↓
[Worker] 发布 Pub/Sub 通知
  ↓
[WebSocket] 推送完成通知给客户端
  ↓
[Worker] 清理临时文件
```

---

## 3. 技术选型

### 3.1 核心技术栈

| 组件 | 技术选型 | 作用 |
|------|---------|------|
| Web 框架 | Go-Zero | API 服务器 |
| 消息队列 | RabbitMQ | 异步任务处理 |
| 缓存/状态 | Redis | 任务状态、进度存储、Pub/Sub |
| 数据库 | MySQL | 持久化存储（文件池、用户等） |
| 对象存储 | 阿里云 OSS | 文件托管 |
| 视频处理 | ffmpeg | 视频压缩 |
| 实时通信 | WebSocket | 进度推送 |

### 3.2 Go 依赖包

```bash
# RabbitMQ 客户端
go get github.com/streadway/amqp

# WebSocket
go get github.com/gorilla/websocket

# Redis (已有)
go get github.com/redis/go-redis/v9
```

---

## 4. 数据结构设计

### 4.1 Redis 数据结构

#### A. 任务状态 (Hash)

```redis
# Key: file_upload_task:{task_id}
# TTL: 24 小时 (86400 秒)

HSET file_upload_task:uuid-xxx-xxx
  task_id         "uuid-xxx-xxx"
  user_id         "123"
  filename        "video.mp4"
  file_hash       "abc123def456"
  file_size       "104857600"
  temp_path       "/tmp/upload-xxx"
  status          "compressing"
  progress        "45"
  message         "视频压缩中..."
  error_msg       ""
  oss_path        ""
  repository_id   ""
  created_at      "2026-02-03 10:00:00"
  updated_at      "2026-02-03 10:05:30"
  
EXPIRE file_upload_task:uuid-xxx-xxx 86400
```

#### B. 用户任务列表 (ZSet)

```redis
# Key: user_upload_tasks:{user_id}
# Score: 时间戳
# Member: task_id

ZADD user_upload_tasks:123 1706932800 "uuid-xxx-xxx"
ZADD user_upload_tasks:123 1706932900 "uuid-yyy-yyy"

# 获取用户最近的上传任务
ZREVRANGE user_upload_tasks:123 0 9  # 最近10个任务
```

#### C. Pub/Sub 频道

```redis
# 频道命名: file_upload_notify:{task_id}
PUBLISH file_upload_notify:uuid-xxx-xxx '{
  "task_id": "uuid-xxx-xxx",
  "status": "compressing",
  "progress": 45,
  "message": "视频压缩中..."
}'
```

### 4.2 任务状态枚举

```go
package constants

const (
    // 任务状态
    StatusPending      = "pending"        // 待处理
    StatusReceived     = "received"       // 已接收（文件已上传到服务器）
    StatusProcessing   = "processing"     // 处理中
    StatusCompressing  = "compressing"    // 压缩中（视频文件）
    StatusUploadingOSS = "uploading_oss"  // 上传到 OSS 中
    StatusCompleted    = "completed"      // 已完成
    StatusFailed       = "failed"         // 失败
)

// 状态对应的中文消息
var StatusMessages = map[string]string{
    StatusPending:      "等待处理",
    StatusReceived:     "文件已接收",
    StatusProcessing:   "正在处理",
    StatusCompressing:  "视频压缩中",
    StatusUploadingOSS: "上传到云端",
    StatusCompleted:    "上传完成",
    StatusFailed:       "上传失败",
}
```

### 4.3 数据库表（仅历史记录）

```sql
-- 文件上传历史记录表（可选，用于长期存储和统计分析）
CREATE TABLE `file_upload_history` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `task_id` varchar(64) NOT NULL COMMENT '任务ID',
  `user_id` bigint NOT NULL COMMENT '用户ID',
  `filename` varchar(255) NOT NULL COMMENT '文件名',
  `file_hash` varchar(64) COMMENT '文件hash',
  `file_size` bigint COMMENT '文件大小(字节)',
  `status` varchar(32) NOT NULL COMMENT '最终状态',
  `error_msg` text COMMENT '错误信息',
  `oss_path` varchar(512) COMMENT 'OSS路径',
  `repository_identity` varchar(64) COMMENT '文件池标识',
  `duration` int COMMENT '处理耗时(秒)',
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  `completed_at` datetime COMMENT '完成时间',
  PRIMARY KEY (`id`),
  KEY `idx_task_id` (`task_id`),
  KEY `idx_user_id` (`user_id`),
  KEY `idx_created_at` (`created_at`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='文件上传历史记录';
```

---

## 5. 核心流程

### 5.1 文件上传流程（API Server）

```go
// handler/upload_file_handler.go

func UploadFileHandler(svcCtx *svc.ServiceContext) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // 1. 接收文件
        file, fileHeader, err := r.FormFile("file")
        if err != nil {
            httpx.ErrorCtx(r.Context(), w, err)
            return
        }
        defer file.Close()
        
        // 2. 保存到临时文件
        tempFile, err := os.CreateTemp("", "upload-*"+path.Ext(fileHeader.Filename))
        if err != nil {
            httpx.ErrorCtx(r.Context(), w, err)
            return
        }
        defer tempFile.Close()
        
        io.Copy(tempFile, file)
        
        // 3. 计算文件 hash
        hash, err := utils.CalculateFileHash(tempFile.Name())
        if err != nil {
            httpx.ErrorCtx(r.Context(), w, err)
            return
        }
        
        // 4. 检查秒传（文件池中是否已存在）
        rp := new(models.RepositoryPool)
        has, _ := svcCtx.DBEngine.Where("hash=?", hash).Get(rp)
        if has {
            // 秒传：直接返回已有文件
            os.Remove(tempFile.Name())
            httpx.OkJsonCtx(r.Context(), w, &types.UploadFileResponse{
                Identity: rp.Identity,
                Status:   "completed",
                Message:  "文件已存在，秒传成功",
            })
            return
        }
        
        // 5. 创建上传任务
        taskID := utils.UUID()
        userID := getUserIDFromContext(r.Context())
        
        task := &models.FileUploadTask{
            TaskID:    taskID,
            UserID:    userID,
            Filename:  fileHeader.Filename,
            FileHash:  hash,
            FileSize:  fileHeader.Size,
            TempPath:  tempFile.Name(),
            Status:    constants.StatusReceived,
            Progress:  10,
            Message:   "文件已接收",
            CreatedAt: time.Now(),
            UpdatedAt: time.Now(),
        }
        
        // 6. 保存任务到 Redis
        err = saveTaskToRedis(svcCtx.RedisClient, task)
        if err != nil {
            httpx.ErrorCtx(r.Context(), w, err)
            return
        }
        
        // 7. 判断是否为视频文件
        isVideo := isVideoFile(fileHeader.Filename)
        
        // 8. 发送消息到 RabbitMQ
        msg := rabbitmq.FileUploadMessage{
            TaskID:   taskID,
            UserID:   userID,
            TempPath: tempFile.Name(),
            Filename: fileHeader.Filename,
            FileHash: hash,
            FileSize: fileHeader.Size,
            IsVideo:  isVideo,
        }
        
        err = svcCtx.RabbitMQ.PublishFileUpload(msg)
        if err != nil {
            httpx.ErrorCtx(r.Context(), w, err)
            return
        }
        
        // 9. 立即返回给客户端
        httpx.OkJsonCtx(r.Context(), w, &types.UploadFileResponse{
            TaskID:  taskID,
            Status:  constants.StatusReceived,
            Message: "文件已接收，正在处理中",
        })
    }
}

// 辅助函数：保存任务到 Redis
func saveTaskToRedis(rdb *redis.Client, task *models.FileUploadTask) error {
    ctx := context.Background()
    key := fmt.Sprintf("file_upload_task:%s", task.TaskID)
    
    // 使用 Hash 存储任务信息
    err := rdb.HSet(ctx, key,
        "task_id", task.TaskID,
        "user_id", task.UserID,
        "filename", task.Filename,
        "file_hash", task.FileHash,
        "file_size", task.FileSize,
        "temp_path", task.TempPath,
        "status", task.Status,
        "progress", task.Progress,
        "message", task.Message,
        "created_at", task.CreatedAt.Format(time.RFC3339),
        "updated_at", task.UpdatedAt.Format(time.RFC3339),
    ).Err()
    
    if err != nil {
        return err
    }
    
    // 设置过期时间 24 小时
    rdb.Expire(ctx, key, 24*time.Hour)
    
    // 添加到用户任务列表
    userTasksKey := fmt.Sprintf("user_upload_tasks:%d", task.UserID)
    rdb.ZAdd(ctx, userTasksKey, redis.Z{
        Score:  float64(time.Now().Unix()),
        Member: task.TaskID,
    })
    
    return nil
}
```

### 5.2 后台 Worker 处理流程

```go
// worker/file_upload_worker.go

func StartFileUploadWorker(svcCtx *svc.ServiceContext) {
    consumer := rabbitmq.NewConsumer(svcCtx.Config.RabbitMQ)
    
    // 消费文件上传队列
    consumer.Consume("file_upload_queue", func(msg rabbitmq.FileUploadMessage) error {
        logx.Infof("开始处理上传任务: %s", msg.TaskID)
        
        // 1. 更新状态：处理中
        updateTaskStatus(svcCtx.RedisClient, msg.TaskID, constants.StatusProcessing, 20, "开始处理文件")
        
        var finalPath string
        
        // 2. 判断是否需要压缩
        if msg.IsVideo {
            // 更新状态：压缩中
            updateTaskStatus(svcCtx.RedisClient, msg.TaskID, constants.StatusCompressing, 30, "视频压缩中...")
            
            // 创建压缩后的临时文件
            compressedPath := msg.TempPath + ".compressed.mp4"
            
            // 执行压缩
            _, err := utils.CompressVideoWithFFmpeg(msg.TempPath, compressedPath, 23, "128k")
            if err != nil {
                updateTaskStatus(svcCtx.RedisClient, msg.TaskID, constants.StatusFailed, 0, "视频压缩失败: "+err.Error())
                os.Remove(msg.TempPath)
                return err
            }
            
            updateTaskStatus(svcCtx.RedisClient, msg.TaskID, constants.StatusCompressing, 60, "视频压缩完成")
            
            // 删除原文件，使用压缩后的文件
            os.Remove(msg.TempPath)
            finalPath = compressedPath
        } else {
            finalPath = msg.TempPath
        }
        
        // 3. 上传到 OSS
        updateTaskStatus(svcCtx.RedisClient, msg.TaskID, constants.StatusUploadingOSS, 70, "上传到云端...")
        
        fileReader, err := os.Open(finalPath)
        if err != nil {
            updateTaskStatus(svcCtx.RedisClient, msg.TaskID, constants.StatusFailed, 0, "打开文件失败")
            return err
        }
        defer fileReader.Close()
        
        ossPath, err := utils.UploadToOSS(fileReader, msg.Filename)
        if err != nil {
            updateTaskStatus(svcCtx.RedisClient, msg.TaskID, constants.StatusFailed, 0, "上传到OSS失败: "+err.Error())
            os.Remove(finalPath)
            return err
        }
        
        updateTaskStatus(svcCtx.RedisClient, msg.TaskID, constants.StatusUploadingOSS, 90, "上传完成，保存信息...")
        
        // 4. 保存到文件池
        rpIdentity := utils.UUID()
        rp := &models.RepositoryPool{
            Identity: rpIdentity,
            Hash:     msg.FileHash,
            Name:     msg.Filename,
            Ext:      path.Ext(msg.Filename),
            Size:     msg.FileSize,
            Path:     ossPath,
        }
        
        _, err = svcCtx.DBEngine.Insert(rp)
        if err != nil {
            updateTaskStatus(svcCtx.RedisClient, msg.TaskID, constants.StatusFailed, 0, "保存文件信息失败")
            os.Remove(finalPath)
            return err
        }
        
        // 5. 更新任务状态：完成
        updateTaskStatusCompleted(svcCtx.RedisClient, msg.TaskID, ossPath, rpIdentity)
        
        // 6. 清理临时文件
        os.Remove(finalPath)
        
        // 7. 保存历史记录（可选）
        saveToHistory(svcCtx.DBEngine, msg.TaskID)
        
        logx.Infof("任务处理完成: %s", msg.TaskID)
        return nil
    })
}

// 更新任务状态
func updateTaskStatus(rdb *redis.Client, taskID, status string, progress int, message string) {
    ctx := context.Background()
    key := fmt.Sprintf("file_upload_task:%s", taskID)
    
    rdb.HSet(ctx, key,
        "status", status,
        "progress", progress,
        "message", message,
        "updated_at", time.Now().Format(time.RFC3339),
    )
    
    // 发布 Pub/Sub 通知
    notification := map[string]interface{}{
        "task_id":  taskID,
        "status":   status,
        "progress": progress,
        "message":  message,
    }
    
    data, _ := json.Marshal(notification)
    rdb.Publish(ctx, fmt.Sprintf("file_upload_notify:%s", taskID), data)
}

// 更新任务为完成状态
func updateTaskStatusCompleted(rdb *redis.Client, taskID, ossPath, repositoryID string) {
    ctx := context.Background()
    key := fmt.Sprintf("file_upload_task:%s", taskID)
    
    rdb.HSet(ctx, key,
        "status", constants.StatusCompleted,
        "progress", 100,
        "message", "上传完成",
        "oss_path", ossPath,
        "repository_id", repositoryID,
        "updated_at", time.Now().Format(time.RFC3339),
    )
    
    // 发布完成通知
    notification := map[string]interface{}{
        "task_id":       taskID,
        "status":        constants.StatusCompleted,
        "progress":      100,
        "message":       "上传完成",
        "repository_id": repositoryID,
    }
    
    data, _ := json.Marshal(notification)
    rdb.Publish(ctx, fmt.Sprintf("file_upload_notify:%s", taskID), data)
}
```

---

## 6. API 设计

### 6.1 文件上传接口

```
POST /api/file/upload
Content-Type: multipart/form-data

Request:
  - file: 文件对象 (required)

Response 200:
{
  "task_id": "uuid-xxx-xxx-xxx",
  "status": "received",
  "message": "文件已接收，正在处理中"
}

Response 200 (秒传):
{
  "identity": "file-identity-xxx",
  "status": "completed",
  "message": "文件已存在，秒传成功"
}

Response 400:
{
  "error": "文件格式不支持"
}

Response 413:
{
  "error": "文件过大，最大支持10GB"
}
```

### 6.2 查询上传进度接口

```
GET /api/file/upload/progress/:task_id

Response 200:
{
  "task_id": "uuid-xxx-xxx-xxx",
  "status": "compressing",
  "progress": 45,
  "message": "视频压缩中...",
  "filename": "video.mp4",
  "file_size": 104857600,
  "created_at": "2026-02-03T10:00:00Z",
  "updated_at": "2026-02-03T10:05:30Z"
}

Response 200 (已完成):
{
  "task_id": "uuid-xxx-xxx-xxx",
  "status": "completed",
  "progress": 100,
  "message": "上传完成",
  "repository_id": "file-identity-xxx",
  "oss_path": "https://bucket.oss-cn-beijing.aliyuncs.com/xxx.mp4"
}

Response 404:
{
  "error": "任务不存在或已过期"
}
```

### 6.3 WebSocket 实时推送

```
WebSocket: ws://localhost:8888/api/file/upload/ws/:task_id

连接成功后接收消息格式:
{
  "task_id": "uuid-xxx-xxx-xxx",
  "status": "uploading_oss",
  "progress": 80,
  "message": "上传到云端..."
}

最终消息 (完成):
{
  "task_id": "uuid-xxx-xxx-xxx",
  "status": "completed",
  "progress": 100,
  "message": "上传完成",
  "repository_id": "file-identity-xxx"
}

最终消息 (失败):
{
  "task_id": "uuid-xxx-xxx-xxx",
  "status": "failed",
  "progress": 0,
  "message": "上传失败",
  "error": "具体错误信息"
}
```

### 6.4 获取用户上传任务列表

```
GET /api/file/upload/tasks?page=1&size=10

Response 200:
{
  "total": 25,
  "page": 1,
  "size": 10,
  "tasks": [
    {
      "task_id": "uuid-xxx-xxx-xxx",
      "filename": "video.mp4",
      "status": "completed",
      "progress": 100,
      "created_at": "2026-02-03T10:00:00Z"
    },
    {
      "task_id": "uuid-yyy-yyy-yyy",
      "filename": "document.pdf",
      "status": "uploading_oss",
      "progress": 75,
      "created_at": "2026-02-03T09:50:00Z"
    }
  ]
}
```

---

## 7. 实现步骤

### 步骤 1：环境准备

```bash
# 1. 安装 RabbitMQ
docker run -d --name rabbitmq \
  -p 5672:5672 \
  -p 15672:15672 \
  -e RABBITMQ_DEFAULT_USER=admin \
  -e RABBITMQ_DEFAULT_PASS=admin123 \
  rabbitmq:3-management

# 2. 安装 Redis (已有，跳过)

# 3. 安装 ffmpeg
brew install ffmpeg  # macOS
# 或
sudo apt-get install ffmpeg  # Ubuntu

# 4. 安装 Go 依赖
cd /Users/xixiu/GolandProjects/cloud_disk/core
go get github.com/streadway/amqp
go get github.com/gorilla/websocket
```

### 步骤 2：更新配置文件

```yaml
# core/etc/core-api.yaml

Name: core-api
Host: 0.0.0.0
Port: 8888
MaxBytes: 10737418240  # 10GB
Timeout: 300000        # 5分钟

Auth:
  AccessSecret: abcdefgh
  AccessExpire: 36000

MySQL:
  DataSource: root:12345678@tcp(127.0.0.1:3306)/cloud_disk?charset=utf8mb4&parseTime=True&loc=Local

Redis:
  Addr: 127.0.0.1:6379
  Password: 
  DB: 0

RabbitMQ:
  Host: 127.0.0.1
  Port: 5672
  User: admin
  Password: admin123
  VHost: /
```

### 步骤 3：创建 RabbitMQ 封装

```bash
# 创建目录
mkdir -p /Users/xixiu/GolandProjects/cloud_disk/core/pkg/rabbitmq
```

创建文件：`core/pkg/rabbitmq/rabbitmq.go`
创建文件：`core/pkg/rabbitmq/message.go`

### 步骤 4：修改上传 Handler

修改文件：`core/internal/handler/upload_file_handler.go`
- 改为异步处理
- 立即返回 task_id

### 步骤 5：创建 Worker

创建文件：`core/worker/file_upload_worker.go`
- 消费 RabbitMQ 消息
- 处理文件上传逻辑

### 步骤 6：添加进度查询接口

在 `core.api` 中添加：
```api
type UploadProgressRequest {
    TaskID string `path:"task_id"`
}

type UploadProgressResponse {
    TaskID      string `json:"task_id"`
    Status      string `json:"status"`
    Progress    int    `json:"progress"`
    Message     string `json:"message"`
    RepositoryID string `json:"repository_id,omitempty"`
}

@server (
    prefix: /api/file
)
service core-api {
    @handler UploadProgressHandler
    get /upload/progress/:task_id (UploadProgressRequest) returns (UploadProgressResponse)
}
```

### 步骤 7：实现 WebSocket

创建文件：`core/internal/handler/upload_websocket_handler.go`

### 步骤 8：启动 Worker

修改 `core/main.go`：
```go
func main() {
    // ... 现有代码
    
    // 启动文件上传 Worker
    go worker.StartFileUploadWorker(svcCtx)
    
    // ... 现有代码
}
```

### 步骤 9：测试

```bash
# 1. 启动服务
cd /Users/xixiu/GolandProjects/cloud_disk/core
go run core.go -f etc/core-api.yaml

# 2. 测试上传
curl -X POST http://localhost:8888/api/file/upload \
  -F "file=@test.mp4"

# 3. 查询进度
curl http://localhost:8888/api/file/upload/progress/{task_id}

# 4. WebSocket 测试（使用浏览器或 wscat）
wscat -c ws://localhost:8888/api/file/upload/ws/{task_id}
```

---

## 8. 部署清单

### 8.1 服务依赖

| 服务 | 版本 | 端口 | 说明 |
|------|------|------|------|
| Go | 1.20+ | - | 运行环境 |
| MySQL | 8.0+ | 3306 | 数据库 |
| Redis | 7.0+ | 6379 | 缓存/状态存储 |
| RabbitMQ | 3.12+ | 5672, 15672 | 消息队列 |
| ffmpeg | 4.4+ | - | 视频处理 |
| 阿里云 OSS | - | - | 对象存储 |

### 8.2 环境变量

```bash
# .env 文件
QQ_MAIL_PASSWORD=your_qq_mail_password
OSS_ACCESS_KEY_ID=your_oss_access_key
OSS_ACCESS_KEY_SECRET=your_oss_secret_key
OSS_REGION=oss-cn-beijing
OSS_BUCKET_NAME=your-bucket-name
```

### 8.3 部署架构

```
┌─────────────────────────────────────┐
│         Nginx (负载均衡)             │
│         - 静态资源                   │
│         - 反向代理                   │
└───────────┬─────────────────────────┘
            │
    ┌───────┴───────┐
    │               │
┌───▼────┐    ┌───▼────┐
│ API 1  │    │ API 2  │  (可水平扩展)
└───┬────┘    └───┬────┘
    │             │
    └──────┬──────┘
           │
    ┌──────▼──────┐
    │  RabbitMQ   │
    └──────┬──────┘
           │
    ┌──────┴──────┐
    │             │
┌───▼────┐  ┌───▼────┐
│Worker 1│  │Worker 2│  (可水平扩展)
└────────┘  └────────┘
```

### 8.4 监控指标

- RabbitMQ 队列长度
- Redis 内存使用率
- 任务处理成功率
- 平均处理时间
- 失败任务统计

---

## 9. 注意事项

### 9.1 性能优化
1. Worker 数量根据 CPU 核心数调整
2. ffmpeg 压缩参数可配置化
3. OSS 上传使用分片上传（大文件）
4. Redis 连接池优化

### 9.2 错误处理
1. 任务失败自动重试（RabbitMQ 重新入队）
2. 最大重试次数限制
3. 死信队列处理
4. 临时文件定期清理

### 9.3 安全性
1. 文件类型白名单
2. 文件大小限制
3. 用户上传频率限制
4. 病毒扫描（可选）

### 9.4 扩展性
1. 支持多种云存储（OSS/S3/七牛云）
2. 支持更多视频格式
3. 支持图片压缩、水印
4. 支持音频处理

---

## 10. 总结

这个异步文件上传系统的核心优势：

✅ **快速响应** - 客户端无需等待，立即返回  
✅ **实时反馈** - WebSocket 推送进度  
✅ **高并发** - 消息队列削峰填谷  
✅ **可扩展** - Worker 可水平扩展  
✅ **高性能** - Redis 存储热点数据  
✅ **可靠性** - 任务可追踪、可重试  

通过这个架构，你的云盘系统可以支持：
- 大文件上传
- 高并发场景
- 实时进度展示
- 自动视频压缩
- 秒传功能

**下一步建议：**
1. 先实现基础流程（上传 → MQ → Worker → OSS）
2. 再添加 WebSocket 实时推送
3. 最后优化性能和错误处理

祝你开发顺利！🚀
